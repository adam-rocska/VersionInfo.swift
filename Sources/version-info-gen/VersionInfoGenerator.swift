import ArgumentParser
import Foundation

@main
struct VersionInfoGenerator: AsyncParsableCommand {
  @Argument(
    help: "The .git directory's path.",
    completion: .directory,
    transform: URL.init(fileURLWithPath:)
  )
  var gitDir: URL

  @Option(
    name: .shortAndLong,
    help: "The output directory for the generated Swift code.",
    completion: .directory,
    transform: URL.init(fileURLWithPath:)
  )
  var outputDir: URL?

  mutating func run() async throws {
    guard let refs = Refs(gitDir: gitDir) else {
      throw ValidationError("Couldn't read refs from \(gitDir.path)")
    }

    let swiftCode = """
      // Source code generated by version-info-gen. DO NOT EDIT.

      // Represents a Git ref provided version.
      // NOTE: Since it's a typealias to a Tuple, it's
      // perfectly fine and compatible with what the VersionInfo
      // Library  provides, despite the copy-pasta we do here.
      typealias Version = (name: String, hash: String)
      typealias Versions = (head: Version, heads: [Version], tags: [Version])

      let versions: Versions = (
        head: ("\(refs.head.name)", "\(refs.head.hash)"),
        heads: [
          \(refs.heads.map { "(\"\($0.name)\", \"\($0.hash)\")" }.joined(separator: ",\n"))
        ],
        tags: [
          \(refs.tags.map { "(\"\($0.name)\", \"\($0.hash)\")" }.joined(separator: ",\n"))
        ]
      )
      """

    if let outputDir = outputDir {
      try FileManager.default.createDirectory(
        at: outputDir,
        withIntermediateDirectories: true
      )

      let swiftFile = outputDir.appendingPathComponent("VersionInfo.swift")
      try swiftCode.write(to: swiftFile, atomically: true, encoding: .utf8)
    } else {
      print(swiftCode)
    }
  }
}
